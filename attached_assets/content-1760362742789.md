```
import { IBrainSerializer } from '../../state/brain/serialize';
import LayersConfig from '../../state/layersConfig';
import GroupLayer from '../../../models/layers/grouplayer';
import ThemeLayer from '../../../models/layers/themelayer';

import LayerManager from '../../layers/layermanager';
import ThemesHelper from '../../themes/themeshelper';
import StateManager from '../../state/statemanager';
import Layer from '../../../models/layers/layer';
import BaseLayer from '../../../models/layers/baselayer';
import { isTimeAwareLayer } from '../../../models/layers/timeawarelayer';
import ErrorManager from '../../error/errormanager';
import LayerWms from '../../../models/layers/layerwms';
import WfsFilter, { WfsOperator } from '../../wfs/wfsfilter';

export type SharedFilter = {
  property: string;
  propertyType?: string;
  operator: WfsOperator;
  value: string;
  value2: string;
};

export type SharedLayer = {
  id: number;
  order: number;
  checked: number;
  isExpanded: number;
  timeRestriction?: string;
  opacity?: number;
  swiped?: 'left' | 'right' | 'no';
  filter?: SharedFilter;
  children: SharedLayer[];
  /**
   * The following attribute will be useful to know which children were explicitly deleted from the view.
   * Without this, we are not able to know if the layer is new in the server configuration
   * And should forcefully be added to the layer tree because the user just didn't know this layer when he has created this shared state
   * Or if it was explicitly removed from the user, and then we won't have to display it again
   */
  excludedChildrenIds: number[];
};

export default class LayersConfigSerializer implements IBrainSerializer<LayersConfig> {
  layerManager: LayerManager;
  stateManager: StateManager;
  themesHelper: ThemesHelper;

  constructor() {
    this.layerManager = LayerManager.getInstance();
    this.themesHelper = ThemesHelper.getInstance();
    this.stateManager = StateManager.getInstance();
  }

  private get state() {
    return this.stateManager.state;
  }

  public brainSerialize(layersConfig: LayersConfig): string {
    return this.serialize(layersConfig.layersList);
  }

  protected serialize(layers: BaseLayer[]) {
    const sharedLayers = this.getSerializedLayerTree(layers);
    return JSON.stringify(sharedLayers);
  }

  public brainDeserialize(str: string) {
    const deserializedLayers = this.deserialize(str);
    // Remove all existing layers
    for (const layer of this.stateManager.state.layers.layersList) {
      this.layerManager.toggle(layer, 'off');
    }
    this.state.layers.layersList = [];

    for (const deserializedLayer of deserializedLayers) {
      this.state.layers.layersList.push(deserializedLayer);
    }
  }

  protected deserialize(str: string) {
    const sharedState = JSON.parse(str);
    return this.getDeserializedLayerTree(sharedState);
  }

  private getSerializedLayerTree(layers: BaseLayer[]) {
    const sharedLayers = [];
    for (const layer of layers) {
      try {
        const sharedLayer = this.getSerializedLayer(layer);
        sharedLayers.push(sharedLayer);
      } catch {
        console.warn(`Cannot serialize layer with id ${layer.id} and name ${layer.name}. Skipping it.`);
      }
    }
    return sharedLayers;
  }

  protected getSerializedLayer(layer: BaseLayer): SharedLayer {
    let isExpanded = false;
    if (layer instanceof GroupLayer || layer instanceof ThemeLayer) {
      isExpanded = layer.isExpanded;
    } else if (layer instanceof Layer && this.layerManager.isLayerWithLegend(layer)) {
      isExpanded = layer.isLegendExpanded;
    }

    // Manage children
    const sharedChildren = [];
    const removedChildren: number[] = [];
    if (layer instanceof GroupLayer || layer instanceof ThemeLayer) {
      // First get the original version of the object
      const originalLayer = this.themesHelper.findBaseLayerById(layer.id) as GroupLayer | ThemeLayer; // Is always of this type.
      for (const child of originalLayer.children) {
        const index = layer.children.findIndex((el) => el.id === child.id);
        if (index >= 0) {
          // Element was found => it is still in the list
          const sharedChild = this.getSerializedLayer(layer.children[index]);
          sharedChildren.push(sharedChild);
        } else {
          removedChildren.push(child.id);
        }
      }
    }

    return {
      id: layer.id,
      order: layer.order,
      checked: Number(layer.active),
      isExpanded: Number(isExpanded),
      opacity: layer instanceof Layer ? layer.opacity : undefined,
      swiped: layer instanceof Layer ? layer.swiped : undefined,
      filter:
        layer instanceof LayerWms && this.layerManager.isLayerWithFilter(layer)
          ? (layer.filter as SharedFilter)
          : undefined,
      timeRestriction: isTimeAwareLayer(layer) ? layer.timeRestriction : undefined,
      children: sharedChildren,
      excludedChildrenIds: removedChildren
    };
  }

  public getDeserializedLayerTree(sharedLayers: SharedLayer[]) {
    const layersList: BaseLayer[] = [];
    for (const sharedLayer of sharedLayers) {
      const layer = this.findBaseLayerById(sharedLayer.id);
      if (layer) {
        this.deserializeLayer(layer, sharedLayer);
        layersList.push(layer);
      } else {
        console.warn(`Cannot find layer with id ${sharedLayer.id} in the available layers`);
      }
    }

    return layersList;
  }

  private deserializeLayer(originalLayer: BaseLayer, sharedLayer: SharedLayer) {
    originalLayer.order = sharedLayer.order;
    originalLayer.isDefaultChecked = Boolean(sharedLayer.checked);
    if (originalLayer instanceof GroupLayer || originalLayer instanceof ThemeLayer) {
      originalLayer.isExpanded = Boolean(sharedLayer.isExpanded);
      // Manage children
      this.removeUnnecessaryChilds(originalLayer, sharedLayer);
      this.checkUnknownLayers(sharedLayer, originalLayer);
    } else if (originalLayer instanceof Layer) {
      if (sharedLayer.opacity) {
        originalLayer.opacity = sharedLayer.opacity;
      }
      if (sharedLayer.swiped) {
        originalLayer.swiped = sharedLayer.swiped;
      }
      if (this.layerManager.isLayerWithLegend(originalLayer)) {
        originalLayer.isLegendExpanded = Boolean(sharedLayer.isExpanded);
      }
      if (originalLayer instanceof LayerWms && sharedLayer.filter) {
        originalLayer.filter = new WfsFilter(
          sharedLayer.filter.property,
          sharedLayer.filter.operator,
          sharedLayer.filter.value,
          sharedLayer.filter.value2,
          sharedLayer.filter.propertyType
        );
      }
    }
    if (isTimeAwareLayer(originalLayer)) {
      originalLayer.timeRestriction = sharedLayer.timeRestriction;
    }
  }

  private checkUnknownLayers(sharedLayer: SharedLayer, originalLayer: GroupLayer | ThemeLayer) {
    // If some layers are present in the shared state but cannot be found in the current list of available layers
    // It probably means that the layers are private ones or that the layer has been delete.
    // Add an infobox for this.
    for (const sharedChild of sharedLayer.children) {
      if (sharedChild.checked === 1) {
        const originalChild = originalLayer.children.find((c) => c.id == sharedChild.id);
        if (!originalChild) {
          ErrorManager.getInstance().pushMessage(
            'unknown-layers-cannot-be-added',
            'Some layer could not be added to the layer-tree. This is either because you do not have the rights for it, or because this layer does not exist anymore.',
            'warning'
          );
        }
      }
    }
  }

  private removeUnnecessaryChilds(originalLayer: GroupLayer | ThemeLayer, sharedLayer: SharedLayer) {
    let reorder = false;
    for (let i = originalLayer.children.length - 1; i >= 0; i--) {
      const child = originalLayer.children[i];
      const serializedChild = sharedLayer.children.find((l) => l.id == child.id);
      if (serializedChild) {
        this.deserializeLayer(child, serializedChild);
      } else {
        // This child exists in the original layer, but not in the shared state.
        // => If it is present in the x list, it was explicitely removed
        // And we can remove it from the current object
        const explicitlyRemoved = sharedLayer.excludedChildrenIds.find((id) => id == child.id);
        if (explicitlyRemoved) {
          originalLayer.children.splice(i, 1);
          console.debug(`Layer ${child.name} was removed from initial state`);
        } else {
          // Otherwise it is a new layer. We do not remove it
          // But we have to set the right order for it.
          // In this case we have to reorder all the layers at this level
          // In order to keep the order defined in the initial group
          console.debug(`Layer ${child.name} will be added to the treeview because it is new`);
          console.debug(`Layer ${originalLayer.name} needs a reorering of its children`);
          reorder = true;
        }
      }
    }

    if (reorder) {
      console.debug(`Reordering childs for layer ${originalLayer.name}`);
      let order = 1;
      for (const child of originalLayer.children) {
        child.order = order++;
      }
    }
  }

  private findBaseLayerById(layerId: number): BaseLayer | null {
    for (const theme of Object.values(this.state.themes._allThemes)) {
      const layer = this.findLayerRecursive(theme, layerId);
      if (layer) {
        return layer;
      }
    }
    return null;
  }

  private findLayerRecursive(layer: BaseLayer, layerId: number): BaseLayer | null {
    if (layer.id === layerId) {
      // When deserializing the layer, we clone it,
      // otherwise the following operation will also
      // affect the layer referenced in other themes
      const foundLayer = layer.clone();
      return foundLayer;
    }

    // Else, we call recursively on the children
    if (layer instanceof GroupLayer || layer instanceof ThemeLayer) {
      for (const childLayer of layer.children) {
        const foundChild = this.findLayerRecursive(childLayer, layerId);
        if (foundChild) {
          return foundChild;
        }
      }
    }
    return null;
  }
}

```